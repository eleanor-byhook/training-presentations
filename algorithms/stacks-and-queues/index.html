<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Stacks and Queues: Basic Algorithms Explained</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/hook.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
			.logo {
				position: absolute;
				top: 0;
				left: 0;
				z-index: 99999999999;
			}

			.logo a img {
				width: 100px;
			}
		</style>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="logo">
			<a href="http://www.byhook.com" target="_blank">
				<img src="lib/img/logo.png" alt="Hook Studios">
			</a>
		</div>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section data-transition="zoom">
					<h1>Stacks & Queues</h1>
					<h2>Basic Algorithms Explained</h2>
					<p>Created by <a href="http://www.bradmurphydev.com" target="_blank">Brad Murphy</a> / <a href="http://www.byhook.com" target="_blank">Hook Studios</a>
					</p>
				</section>

				<section data-transition="concave">

					<img data-src="lib/img/hello.gif" alt="Farley Is Awesome" width="200">
					<h2>Hello There</h2>
					<p>
						After reading through <em><a href="https://www.packtpub.com/application-development/learning-javascript-data-structures-and-algorithms" target="_blank">Learning Javascript Data Structures and Algorithms</a></em>, we were asked to present some of the concepts we have learned.
					</p>
					<p class="fragment">
						The material varies from basic to complicated.  The material I'm going to present today are the two most basic concepts introduced that will build a foundation for everything else.
					</p>

				</section>

				<section data-transition="concave">

					<section data-transition="concave">
						<img data-src="lib/img/magic.gif" alt="Dat Shiloh" width="400">
						<h2>Magical Array Functions</h2>
						<p>
							Before anything, it's important to quickly address some of the magical array functions that Javascript has already given us:
						</p>
					</section>

					<section data-transition="concave">

						<table>
							<thead>
								<tr>
									<th>Function</th>
									<th>Definition</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>push()</td>
									<td>Add element(s) to the end of an array and return the new length of the array.</td>
								</tr>
								<tr>
									<td>pop()</td>
									<td>Removes the last element from an array and returns that element.</td>
								</tr>
								<tr>
									<td>shift()</td>
									<td>Removes the first element from an array and returns that element.</td>
								</tr>
							</tbody>
						</table>

						<p>
							So with this knowledge, let's move onto <strong>Stacks</strong>.
						</p>

					</section>

				</section>

				<section data-transition="convex">

					<section data-transition="convex">

						<img data-src="lib/img/books.gif" alt="Books And Stuff">
						<h2>Stacks</h2>
						<p>
							You can think of <strong>stacks</strong> like a pile of books.  A <strong>stack</strong> is an ordered collection of items that follows the <em>LIFO (Last In, First Out)</em> principle.  New items and the removal of existing items takes place at the same end.
						</p>

					</section>

					<section data-transition="convex">

						<p>Let's define the functions we need to make a <strong>stack</strong> class:</p>

						<table>
							<thead>
								<tr>
									<th>Function</th>
									<th>Definition</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>push(element)</td>
									<td>This adds a new item (or several items) to the top of the stack.</td>
								</tr>
								<tr class="fragment">
									<td>pop()</td>
									<td>This removes the top item from the stack. It also returns the removed element.</td>
								</tr>
								<tr class="fragment">
									<td>peek()</td>
									<td>This returns the top element from the stack. The stack is not modified (it does not remove the element; it only returns the element for information purposes).</td>
								</tr>
							</tbody>
						</table>

					</section>

					<section data-transition="convex">

						<table>
							<tbody>
								<thead>
									<tr>
										<th>Function</th>
										<th>Definition</th>
									</tr>
								</thead>
								<tr>
									<td>isEmpty()</td>
									<td>This returns true if the stack does not contain any elements and false if the size of the stack is bigger than 0.</td>
								</tr>
								<tr class="fragment">
									<td>clear()</td>
									<td>This removes all the elements of the stack.</td>
								</tr>
								<tr class="fragment">
									<td>size()</td>
									<td>This returns how many elements the stack contains. It is similar to the length property of an array.</td>
								</tr>
							</tbody>
						</table>

					</section>

					<section data-transition="convex">

						<p>To make a <strong>stack</strong> class, just put those methods to use:</p>

						<pre><code class="hljs" data-trim contenteditable>
function Stack() {

	var items = [];

	this.push = function(element) {
		items.push(element);
	}; // Add an item to the end of the array.

	this.pop = function() {
		return items.pop();
	}; // Remove an item from the end of the array.

	this.size = function() {
		return items.length;
	}; // Check the size of the array.

	this.clear = function() {
		items = [];
	}; // Empty the array.

	this.isEmpty = function() {
		return items.length == 0;
	}; // Return true if the array is empty.

	this.peek = function() {
		return items[items.length - 1];
	}; // Look at the last item in the array.

}
						</code></pre>

					</section>

			</section>

			<section data-transition="concave">

				<section data-transition="concave">

					<img data-src="lib/img/line.gif" alt="Waiting in line sucks!">
					<h2>Queues</h2>
					<p>
						You can think of <strong>queues</strong> as a ticket line for the movies.  A <strong>queue</strong> is an ordered collection of items that follows the <em>FIFO (First In, First Out)</em> principle.  Adding new elements in a queue is at the tail and the removal is at the front. The newest element added must wait at the end of the queue.
					</p>

				</section>

				<section data-transition="concave">

						<p>Let's define the functions we need to make a <strong>queue</strong> class:</p>

					<table>
						<thead>
							<tr>
								<th>Function</th>
								<th>Definition</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>enqueue(elements)</td>
								<td>This adds a new item (or several items) at the back of the queue.</td>
							</tr>
							<tr class="fragment">
								<td>dequeue()</td>
								<td>This removes the first item from the queue (the item that is in the front of the queue). It also returns the removed element.</td>
							</tr>
						</tbody>
					</table>

				</section>


				<section data-transition="concave">

					<table>
						<thead>
							<tr>
								<th>Function</th>
								<th>Definition</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>front()</td>
								<td>This returns the first element from the queue, the first one added, and the first one that will be removed from the queue. The queue is not modified (it does not remove the element; it only returns the element for information purposes).</td>
							</tr>
							<tr class="fragment">
								<td>isEmpty()</td>
								<td>This returns true if the queue does not contain any elements and false if the queue is bigger than 0.</td>
							</tr>
							<tr class="fragment">
								<td>size()</td>
								<td>This returns how many elements the queue contains. It is similar to the length property of the array.</td>
							</tr>
						</tbody>
					</table>

				</section>

				<section data-transition="concave">

					<p>Much like the stacks, constructing a <strong>queue</strong> is easy.  It can be replicated like so:</p>

					<pre><code class="hljs" data-trim contenteditable>
function Queue() {

	var items = [];

	this.enqueue = function(element) {
	  items.push(element);
	}; // Add an item to the end of the array.

	this.dequeue = function() {
	  return items.shift();
	}; // Remove an item from the beginning of the array.

	this.front = function() {
	  return items[0];
	}; // Return the first item in the array.

	this.isEmpty = function() {
	  return items.length == 0;
	}; // Return true if the array is empty.

	this.clear = function() {
	  items = [];
	}; // Empty the array.

	this.size = function() {
	  return items.length;
	}; // Return the length of the array.

}
					</code></pre>

					<p>Voila, <strong>stacks</strong> and <strong>queues</strong>.</p>

				</section>

			</section>

			<section data-transition="convex">

				<section data-transition="convex">
					<img data-src="lib/img/doit.gif" alt="Just Do It">
					<h2>Implementation</h2>
					<p>
						So you're probably wondering - these are great, but when would I use one of these principles?
						Great question, let's find out...
					</p>
				</section>

				<section data-transition="convex">
					<h2>Stack</h2>
					<p>The first example I gave of a stack was a stack of books.  Let's say we're going to make an
						app that keeps a list of all the books we put into it.  It will of course use the <em>LIFO (Last In, Last Out)</em> principle.  So all books that we add and remove will be from the top of the list of the books.
				</section>

				<section data-transition="convex">

					<p>We could define the app like so:</p>

					<pre><code class="hljs" data-trim contenteditable>
function Stack() {

	var books = [];

	this.push = function(book) {
		books.push(book);
	}; // Add an item to the end of the array.

	this.pop = function() {
		return books.pop();
	}; // Remove an item from the end of the array.

	this.size = function() {
		return books.length;
	}; // Check the size of the array.

	this.clear = function() {
		books = [];
	}; // Empty the array.

	this.isEmpty = function() {
		return books.length == 0;
	}; // Return true if the array is empty.

	this.peek = function() {
		return books[books.length - 1];
	}; // Look at the last item in the array.

}

var books = new Stack();
					</code></pre>

				</section>

				<section data-transition="convex">

					<p>So let's say we add three books to the stack:</p>
					<pre><code class="hljs" data-trim contenteditable>
books.push('Along Came A Spider');
books.push('Kiss The Girls');
books.push('Cat & Mouse');
					</code></pre>

				</section>

				<section data-transition="convex">
					<p>This is what our book stack would look like:</p>
					<img data-src="lib/img/book1.jpg" alt="Books">
				</section>

				<section data-transition="convex">

					<p>But what if we wanted to remove Cat & Mouse?  Since you know... we already read it.  We would use the pop method:</p>
					<pre><code class="hljs" data-trim contenteditable>
books.pop();
					</code></pre>

				</section>

				<section data-transition="convex">
					<p>It would look like this, right?</p>
					<img data-src="lib/img/book2.jpg" alt="Books">
				</section>

				<section data-transition="convex">
					<p>But let's say - we wanted to see what the next book is?  We'd use the peek() method.:</p>
					<pre><code class="hljs" data-trim contenteditable>
books.peek();
					</code></pre>

				</section>

				<section data-transition="convex">
					<p>And, much to Brendan Dassey's dismay... we'd get this.</p>
					<img data-src="lib/img/book3.jpg" alt="Books">
				</section>

				<section data-transition="concave">
					<h2>Queue</h2>
					<p>So for <strong>queues</strong>, the best practical example I can think of in software would be a print queue.  It will of course use the <em>FIFO (First In, First Out)</em> principle.  So that each document is queued and the oldest document in the queue is printed first.
				</section>

				<section data-transition="concave">

					<p>We could define the app like so:</p>

					<pre><code class="hljs" data-trim contenteditable>
function Queue() {

	var documents = [];

	this.enqueue = function(document) {
	  documents.push(document);
	}; // Add an item to the end of the array.

	this.dequeue = function() {
	  return documents.shift();
	}; // Remove an item from the beginning of the array.

	this.front = function() {
	  return documents[0];
	}; // Return the first item in the array.

	this.isEmpty = function() {
	  return documents.length == 0;
	}; // Return true if the array is empty.

	this.clear = function() {
	  documents = [];
	}; // Empty the array.

	this.size = function() {
	  return documents.length;
	}; // Return the length of the array.

}

var printer = new Queue();
					</code></pre>

				</section>

				<section data-transition="concave">

					<p>So let's say we wanted to print three documents:</p>
					<pre><code class="hljs" data-trim contenteditable>
printer.enqueue('Document #1');
printer.enqueue('Document #2');
printer.enqueue('Document #3');
					</code></pre>

				</section>

				<section data-transition="concave">

					<p>Remember print queues?  It would look something like this:</p>
					<img data-src="lib/img/print1.jpg" alt="Print">

				</section>

				<section data-transition="concave">

					<p>So let's go ahead and print <em>Document #1</em> and dequeue it:</p>
					<pre><code class="hljs" data-trim contenteditable>
printer.dequeue();
					</code></pre>

				</section>

				<section data-transition="concave">

					<p>We'd get a que that looks like this:</p>
					<img data-src="lib/img/print2.jpg" alt="Print">

				</section>

				<section data-transition="concave">

					<p>And of course if we wanted to see what's at the front:</p>
					<pre><code class="hljs" data-trim contenteditable>
printer.front();
					</code></pre>

				</section>

				<section data-transition="concave">

					<p>We'd just look at our queue and see that <em>Document #2</em> is the next document to be printed:</p>
					<img data-src="lib/img/print2.jpg" alt="Print">

				</section>

			</section>

			<section data-transition="concave">

				<section data-transition="concave">

					<img data-src="lib/img/performance.gif" alt="Performance">
					<h2>Performance</h2>
					<p>
						The only metric that matters here is how well this algorithm performs.  As a challenge, I took the existing <strong>stack</strong> and <strong>queue</strong> algorithm's using arrays and then wrote them over again without using an array as a data structure.
					</p>

				</section>

				<section data-transition="concave">

					<h2>Stack</h2>

					<pre><code class="hljs" data-trim contenteditable>
function Stack() {

	var Node = function(element) {
	  this.element = element;
	  this.prev = null;
	};

	this.length = 0;
	this.tail = null;

	this.push = function(element) {
	  this.length++;
	  var node = new Node(element);
	  node.prev = this.tail;
	  this.tail = node;
	}.bind(this);

	this.pop = function() {
	  this.tail = this.tail.prev;
	  this.length--;
	}.bind(this);

	this.size = function() {
	  return this.length;
	}

	this.isEmpty = function() {
	  return this.length === 0;
	}.bind(this);

}

var stack = new Stack();
					</code></pre>

					<a href="http://jsperf.com/stack-array-vs-no-array" target="_blank">How does it match up?</a>

				</section>

				<section data-transition="concave">

					<h2>Queue</h2>

					<pre><code class="hljs" data-trim contenteditable>
function Queue() {

	var Node = function(element) {
		this.element = element;
		this.next = null;
	};

	this.length = 0;
	this.head = null;
	this.tail = null;

	this.enqueue = function(element) {
		this.length++;
		var node = new Node(element);
		if (!this.head) {
			this.head = node;
			this.tail = node;
		} else {
			this.tail.next = node;
			this.tail = node;
		}
	}.bind(this);

	this.dequeue = function() {
		var dequeued = this.head;
		if (this.head) {
			this.head = this.head.next;
		}
		this.length--;
		return dequeued;
	}.bind(this);

	this.size = function() {
		return this.length;
	};

	this.isEmpty = function() {
		return this.length === 0;
	}.bind(this);

}

var queue = new Queue();
					</code></pre>

					<a href="http://jsperf.com/queue-array-vs-no-array" target="_blank">How does it match up?</a>

				</section>

				<section data-transition="concave">

					<p>So that's interesting...</p>
					<p>Let's see what the difference is:</p>
					<p>
						<a href="http://jsperf.com/queue-boatloads" target="_blank">Enqueue</a> /
						<a href="http://jsperf.com/dequeue-boatloads" target="_blank">Dequeue</a>
					</p>

				</section>

			</section>

			<section data-transition="zoom">

				<img data-src="lib/img/finito.gif" alt="Mind Blown">
				<h2>Thanks.</h2>

			</section>


    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
