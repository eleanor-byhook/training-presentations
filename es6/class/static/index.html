<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ES6 - Class</title>

		<meta name="description" content="New ES6 Class syntax">
		<meta name="author" content="Herb">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/zenburn.css">
		<link rel="stylesheet" href="css/hook.css">
		<link rel="stylesheet" href="css/index.css">

	</head>

	<body>

		<div class="reveal">
			
			<!-- hook svg -->
			<a href="http://www.byhook.com" target="_blank" id="logoLink">
				<svg version="1.1" id="logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
				   viewBox="0 0 88 131" style="enable-background:new 0 0 88 131;" xml:space="preserve">
				  <g>
				    <g>
				      <path class="logo-fill" d="M63.7,0.1L63.7,0.1C44.3,0.1,44.3,14.9,44.3,24v14.7c0,9.1,0,23.9,19.3,23.9h0C83,62.7,83,47.9,83,38.7V24
				        C83,14.9,83,0.1,63.7,0.1z M68.2,42.2c0,2.2,0,5.7-4.6,5.7s-4.6-3.5-4.6-5.7V20.6c0-2.2,0-5.7,4.6-5.7s4.6,3.5,4.6,5.7V42.2z"/>
				      <path class="logo-fill" d="M24,1.2v21.6c0,0.7-0.5,1.2-1.2,1.2h-6.9c-0.7,0-1.2-0.5-1.2-1.2V1.2c0-0.7-0.5-1.2-1.2-1.2H1.2
				        C0.5,0,0,0.5,0,1.2V24v14.8v22.7c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V39.9c0-0.7,0.5-1.2,1.2-1.2h6.9
				        c0.7,0,1.2,0.5,1.2,1.2v21.6c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V38.8V24V1.2c0-0.7-0.5-1.2-1.2-1.2H25.2
				        C24.5,0,24,0.5,24,1.2z"/>
				    </g>
				    <path class="logo-fill" d="M19.3,68.5L19.3,68.5C0,68.5,0,83.2,0,92.4v14.7c0,9.1,0,23.9,19.3,23.9h0c19.3,0,19.3-14.7,19.3-23.9V92.4
				      C38.7,83.2,38.7,68.5,19.3,68.5z M23.9,110.5c0,2.2,0,5.7-4.6,5.7h0c-4.6,0-4.6-3.5-4.6-5.7V88.9c0-2.2,0-5.7,4.6-5.7h0
				      c4.6,0,4.6,3.5,4.6,5.7V110.5z"/>
				    <path class="logo-fill" d="M72.5,131H87c0.8,0,1.3-0.8,0.9-1.5l-15.8-29.3c-0.1-0.3-0.2-0.6,0-0.9l12.5-29.6c0.3-0.7-0.2-1.4-0.9-1.4
				      H69.8c-0.4,0-0.8,0.2-0.9,0.6l-9.2,21.8C59.5,91.1,59,91,59,90.6V69.4c0-0.6-0.5-1-1-1H45.3c-0.6,0-1,0.5-1,1V130c0,0.6,0.5,1,1,1
				      H58c0.6,0,1-0.5,1-1v-21.6c0-0.4,0.5-0.5,0.6-0.2l12,22.3C71.8,130.8,72.1,131,72.5,131z"/>
				  </g>
				</svg>
			</a>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>ES6 Class</h1>
					<h3>A Renewal of Thoughts</h3>
					<img src="images/lisa-doh.gif" alt="class checklist">
				</section>

				<section class="text-align-left">
					<h2>ES6 Class Syntax</h2>
					<p>JavaScript is a class-free, object-oriented language, and as such, it uses prototypal inheritance instead of classical inheritance. ES6 introduced classes that provide a much simpler and clearer syntax to creating constructors and dealing with inheritance. </p>
					<p>They are effectively simple sugaring over prototype-based OO, offering a convenient declarative form for class patterns which encourage interoperability.</p>
				</section>

				<!-- es5 the old way -->
				<section>
					<section>
						<h2>ES5 constructor functions</h2>
						<pre>
							<code class="hljs" data-trim contenteditable>
var Polygon = function(height, width) {
	this.name = 'Polygon';
	this.height = height;
	this.width = width;
};

Polygon.prototype.sayName = function() {
	console.log('Hello, I am a', this.name + '.');
};

Polygon.protoype.sayHistory = function() {
	console.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).');
};
						</code>
					</pre>

					</section>
					<section>
						<h2>ES5 constructor functions</h2>
						<h4>Or perhaps something like this</h4>
						<pre>
							<code class="hljs" data-trim contenteditable>
var Polygon = function(height, width) {
	this.name = 'Polygon';
	this.height = height;
	this.width = width;

	this.sayName = function() {
		console.log('Hello, I am a', this.name + '.');
	};

	this.sayHistory = function() {
		console.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).');
	};
};

						</code>
					</pre>
					</section>

					<section>
						<h2>ES5 constructor functions</h2>
						<pre>
							<code class="hljs" data-trim contenteditable>
var polygon = new Polygon(300, 400);
polygon.sayName();
console.log('width: ', polygon.width);
console.log('height: ', polygon.height);

						</code>
					</pre>

					</section>
				</section>

				<!-- es6 class syntax -->
				<section>
					<section>
						<h2>ES6 Class Syntax</h2>
						<p>Under the hood, ES6 classes are not something that is radically new; they mainly provide more convenient syntax to create old-school constructor functions.</p>
						<pre>
							<code class="hljs" data-trim contenteditable>
class Polygon {
	constructor(height, width) {
		this.name = 'Polygon';
		this.height = height;
		this.width = width;
	}

	sayName() {
		console.log('Hello, I am a', this.name + '.');
	}

	sayHistory() {
		console.log('"Polygon" is derived from the Greek polus (many) ' + 'and gonia (angle).');
	}
};
							</code>
						</pre>

						<p><small>Our Polygon class above is an example of a <strong>Class declaration</strong>. You need to use the <strong>class</strong> keyword, and a name for the class.</small></p>

					</section>

					<section>
						<h2>ES6 Class Syntax</h2>
						<p><small>ES6 classes also support <strong>Class expressions</strong>, which has a similar syntax to a class declaration. However, with class expressions, you are able to omit the class name.</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
const MyPoly = class Poly {
	getPolyName() {
		console.log('Hi. I was created with a Class expression. My name is ' + Poly.name);
	}
};

let inst = new MyPoly();
inst.getPolyName();
							</code>
						</pre>

						<p><small>Class body and behavior remains the same in both the ways.</small></p>

					</section>

					<section>
						<h2>ES6 Class Syntax</h2>
						<p>Classes are used just like ES5 constructor functions</p>
						<pre>
							<code class="hljs" data-trim contenteditable>
var polygon = new Polygon(300, 400);
polygon.sayName();
console.log('width: ', polygon.width);
console.log('height: ', polygon.height);

						</code>
					</pre>

					</section>
				</section>

				<!-- extends -->
				<section>
					<section>
						<h2>ES6 Class Extends</h2>
						<p>By using the <strong>extends</strong> clause, a class can inherit static and non-static properties of another constructor (which may or may not be defined using a class).</p>
						
					</section>

					<section>
						<h2>ES6 Class Extends</h2>
						<p>Classes support extending other classes, but can also extend other objects.</p>
						<p><small>Lets make a Drink class</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
class Drink {
	constructor(name, type) {
		this._name = name;
		this._type = type;
	}

	get name() {
		return this._name;
	}

	get type() {
		return this._type;
	}

	toString() {
		return `Drink ${this._name} ${this._type}`;
	}
};

							</code>
						</pre>

						<p><small>Whatever you extend must be a constructor.</small></p>

					</section>

					<section>
						<h2>ES6 Class Extends</h2>
						<p><small>Let's create an instance of Drink</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
let drink = new Drink('Pepsi Cola', 'soda');

console.log(drink.name); // Pepsi Cola
console.log(drink.type); // soda
console.log(drink.toString()); // Drink Pepsi Cola soda

							</code>
						</pre>
						<p><small>Nothing new or crazy...</small></p>
					</section>

					<section>
						<h2>ES6 Class Extends</h2>
						<p><small>Now, let's create a Beer class that extends our Drink class</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
class Beer extends Drink {
	constructor(name, type) {
		super(name, type); // we'll go over super next
	}

	toString() {
		return `Beer ${this.name} ${this.type}`;
  	}
};

							</code>
						</pre>

						<p><small>Let's create an instance of Beer</small></p>

						<pre>
							<code class="hljs" data-trim contenteditable>
let beer = new Beer('Hopsacutioner', 'IPA');

console.log(beer.name); // Hopsacutioner
console.log(beer.type); // IPA
console.log(beer.toString()); // Beer Hopsacutioner IPA

							</code>
						</pre>

					</section>

					<section>
						<h2>ES6 Class Extends</h2>
						<p>Using <strong>super</strong> in the object literals</p>
						<p><small>The super keyword can also be used in the concise methods of the object literals. The super keyword in concise methods of the object literals, has the same value as the [[prototype]] property of the object defined by the object literal.</small></p>
						<p><small>In the object literals, super is used to access the over-ridden properties by the child object.</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
var obj1 = {
	print(){
		console.log("Hello");
	}
};

var obj2 = {
	print(){
		super.print();
	}
};

Object.setPrototypeOf(obj2, obj1);
obj2.print(); //Output "Hello"

							</code>
						</pre>

						<p><small>The <strong>super</strong> keyword is used in a class constroctor method to call the parent constructor.<br>When used inside methods of a class, it references the static and non-static method of the parent constroctor.</small></p>

					</section>
				</section>

				<section>
					<section>
						<h2>ES6 Class Syntax</h2>
						<p>Inside the body of a a class definition</p>
						<p><small>A class body can only contain methods, but not data properties. Prototypes having data properties is generally considered an anti-pattern, so this just enforces a best practice.</small></p>
					</section>

					<section>
						<h2>ES6 Class Syntax</h2>
						<p><small>Let’s examine three kinds of methods that you often find in class definitions.</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
class Foo {
    constructor(prop) {
        this.prop = prop;
    }

    prototypeMethod() {
        return 'so prototypical';
    }

    static staticMethod() {
        return 'you so classy';
    }
};

const foo = new Foo(123);

							</code>
						</pre>
					</section>

					<section>
						<h2>ES6 Class Syntax - pseudo-method</h2>
						<p><small>Defines the function that represents the class</small></p>
						<pre>
							<code class="hljs" data-trim contenteditable>
>Foo === Foo.protoype.constructor
true
> typeof Foo
'function'
							</code>
						</pre>

						<p><small>It is sometimes called a class constructor. It has features that normal constructor functions don’t have. Mmainly the ability to constructor-call its superconstructor via super().</small></p>
					</section>

					<section>
						<h2>ES6 Class Syntax - prototype methods</h2>
						<p><small>All the methods in the body of the class are added to the prototype property of the class. The prototype property is the prototype of the objects created using class.</small></p>

						<pre>
							<code class="hljs" data-trim contenteditable>
> typeof Foo.prototype.prototypeMethod
'function'
> foo.prototypeMethod()
'so prototypical

							</code>
						</pre>

						<p><small>Here, we can see that the prototypeMethod method was added to the prototype property of the class defined in the first slide of this section (Foo).</small></p>
					</section>

					<section>
						<h2>ES6 Class Syntax - static methods</h2>
						<p><small>The methods that are added to the body of the class with the static prefix are called as static methods. Static methods are the own methods of the class, that is, they are not added to the prototype property of the class, rather they are added to the class itself.</small></p>

						<pre>
							<code class="hljs" data-trim contenteditable>
> typeof Foo.staticMethod
'function'
> Foo.staticMethod()
'you so classy'
							</code>
						</pre>

						<p><small>Static methods are often used to create utility functions for an application.</small></p>
					</section>

				</section>

				<section>
					<section id="fragments">
						<h2>ES6 Classes</h2>
						<h3>They Hit it out the park!</h3>
						<p class="fragment">Actually....</p>
						<p class="fragment">There are many in the dev community that say</p>
						<h3 class="fragment"><strong>They blew it!</strong></h3>
					</section>

					<section>
						<h2>ES6 Classes</h2>
						<p>Class doesn’t give you any power that isn’t already supplied by factory functions and the prototypal OO built into the language. All you’re doing when you create a class is opting into a less powerfull, less flexible mechanism and a whole lot of pitfalls and pain.</p>
						<p>In JavaScript, any function can instantiate and return objects. When you do so without a constructor, it’s called a factory function. <strong>class</strong> can’t compete with the power and flexibility of factories</p>

					</section>

					<section>
						<h2>ES6 Classes</h2>
						<p>Here are some <em>opinionated</em>  points made through out the articles and blogs I read about ES6 class</p>
						<small>
							<ul>
								<li>Although it is possible to emulate classical inheritance patterns in JS, classical inheritance is not built directly into the language, and many people believe prototypal inheritance to be a more flexible and freeing paradigm due to its less rigid nature.</li>
							</ul>
						</small>

						<aside class="notes">
							<small>
								<p>
									This indirection was intended to make the language seem more familiar to classically trained programmers, but failed to do that, as we can see from the very low opinion Java programmers have of JavaScript. JavaScript’s constructor pattern did not appeal to the classical crowd. It also obscured JavaScript’s true prototypal nature. As a result, there are very few programmers who know how to use the language effectively.
								</p>
							</small>
						</aside>
					</section>

					<section>
						<h2>ES6 Classes</h2>
						<small>
							<ul>
								<li>The ES6 class syntax, constructors, the new keyword, etc. are ideas taken from the classical inheritance model to make programmers coming from languages like C++, Java, C#, etc. more comfortable and do not really belong in JavaScript. ES6 class syntax is essentially syntactic sugar that will end up obfuscating the true nature of JavaScript and confusing the next generation of programmers learning it.</li>
							</ul>
						</small>

						<aside class="notes">
							<small>
								<ul>
									<li>Protoypal inheritance - need 2 things</li>
									<li>A way to create a new object</li>
									<li>A way to extend an existin object</li>
								</ul>

								<p>Classes, Objects, Interfaces, Abstract Classes, Final Classes, Virtual base classes, constructors, destructors</p>
							</small>
						</aside>
					</section>

					<section>
						<h2>ES6 Classes</h2>
						<small>
							<ul>
								<li>While prototypal inheritance is very powerful in its own right, it is important to know that there is a growing movement among developers to shift away from inheritance in favor of object composition.</li>
							</ul>
						</small>

						<aside class="notes">
							<small>
								<p>
									The problem with JavaScript is that since any function can be used as a constructor we need to distinguish a normal function call from a constructor function call; and this is achieved using the new keyword. However, this breaks functional features in JavaScript since new is a keyword, not a function.
								</p>
							</small>
						</aside>
					</section>

					<section>
						<h2>ES6 Classes</h2>
						<small>
							<ul>
								<li>Whether you choose to use prototypal inheritance, composition, or some combination of the two, you should consider using factory functions, object literals, prototypes, Object.create(), Object.assign(), etc. while avoiding ES6 classes, constructors, and the new keyword altogether.</li>
							</ul>
						</small>
					</section>
				</section>

				<section class="text-align-left">
					<h2>THE END</h2>
					<p>The ES6 classes aim to provide a much simpler and clearer syntax for dealing with the constructors and inheritance.  ES6 classes are just new a syntax for the existing model.  Classes are simply functions. It's just a new syntax for creating functions that are used as constructors.</p>

					<p>Although the new ES6 Class syntax fails to receive a lot of fanfare from many developers because of its lack of bringing anything truly new to the table, it is a good start and efforts to fix it are well in discussions.</p>
				</section>

			</div>

		</div>

		<script src="js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

		<!-- <script src="js/vendor.js"></script> -->
		<script src="js/main.build.js"></script>

	</body>
</html>
